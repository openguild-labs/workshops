---
title: Building a production Rust system
description: "Going through concepts used in building scalable Rust system"
duration: 90 minutes
---
## Where Rust is being used in Production - Case studies

### Discord
Discord, a major platform for organizing community and chat, was having a service called "Read States". Its sole purpose is to keep track of which channels and messages you have read. Read States is accessed every time you connect to Discord, every time a message is sent and every time a message is read. In short, Read States is in the hot path. Discord team wants to make sure Discord feels super snappy all the time, so theu need to make sure Read States is quick. With the Go implementation, the Read States service was fast most of the time, but every few minutes they saw large latency spikes that were bad for user experience. After investigating, the spikes were due to core Go features: its memory model and garbage collector (GC).

![Discord server resources go implementation](/workshops/syllabus/module/0.1-slides-images/discord-server-resources-go.png)

So the Discord team adopted Rust for their Read State service. Rust does not have garbage collection, so they figured it would not have the same latency spikes Go had.

Rust uses a relatively unique memory management approach that incorporates the idea of memory “ownership”. Basically, Rust keeps track of who can read and write to memory. It knows when the program is using memory and immediately frees the memory once it is no longer needed. It enforces memory rules at compile time, making it virtually impossible to have runtime memory bugs. You do not need to manually keep track of memory. The compiler takes care of it.

Let's dive into details: [https://discord.com/blog/why-discord-is-switching-from-go-to-rust](https://discord.com/blog/why-discord-is-switching-from-go-to-rust)


### AWS Firecracker
Firecracker is an open source virtualization technology that is purpose-built for creating and managing secure, multi-tenant container and function-based services.
Firecracker enables you to deploy workloads in lightweight virtual machines, called microVMs, which provide enhanced security and workload isolation over traditional VMs, while enabling the speed and resource efficiency of containers. Firecracker was developed at Amazon Web Services to improve the customer experience of services like AWS Lambda and AWS Fargate .

Firecracker is a virtual machine monitor (VMM) that uses the Linux Kernel-based Virtual Machine (KVM) to create and manage microVMs. Firecracker has a minimalist design. It excludes unnecessary devices and guest functionality to reduce the memory footprint and attack surface area of each microVM. This improves security, decreases the startup time, and increases hardware utilization. Firecracker is generally available on 64-bit Intel, AMD and Arm CPUs with support for hardware virtualization.

Firecracker is used by/integrated with (in alphabetical order): appfleet, containerd via firecracker-containerd, Fly.io, Kata Containers, Koyeb, Northflank, OpenNebula, Qovery, UniK, Weave FireKube (via Weave Ignite), webapp.io, and microvm.nix. Firecracker can run Linux and OSv guests. Our latest roadmap can be found here.

### Zed editor
Zed is a high-performance, multiplayer code editor from the creators of Atom and Tree-sitter. It's also open source.

### Reth (EVM based)


## Punchline


---
